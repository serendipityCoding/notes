{
  "title": "Feature Column",
  "cells": [
    {
      "type": "markdown",
      "data": "* Definition: intermediaries between raw data and estimators\n* Input to a DNN is numeric. For text, represent categorical values as simple vectors.\n> category: kitchenware, electronics, sports\n> if 1 represents the presence of a value, 0 represents the absence of a value for a produce: [0, 0, 1]\n* Numerical Column:\n  * numeric\\_feature\\_column = tf.feature\\_column.numeric\\_column(key=“”, dtype=“”, shape=“”)\n* Bucketized Column: split value into different categories based on numerical ranges\n> As the categorisation splits a single input number into a four-element vector, the model new can learn four individual weights rather than just one.\n  * numeric\\_feature\\_colun=tf.feature\\_column.numeric\\_column(“ “)\n  * bucketized\\_feature\\_column= tf.feature\\_column\\_bucketized\\_column(source\\_coulmn=numeric\\_feature\\_column, boundaries=[]\n**a three-element boundaries vector creates a four-element bucketized vector**\n* Categorical Identity Column: a special case of bucketized columns, each bucket represent a single unique integer\n  * identity\\_feature\\_column = tf.feature\\_column.categorical\\_column\\_with\\_identity(key=“”, num\\_buckets=“”)\n  * input\\_fn() should return a dictionary containing the key.\n* Categorical Vocabulary Column: represent string as a vector \n  * map each string to an integer based on an explicit vocabulary\n  * vocabulary\\_feature\\_column= tf.feature\\_column.categorical\\_column\\_with\\_vocabulary\\_list(key=“ a feature returned by input\\_fn()”, vocabulary\\_list=[])\n  * vocabulary\\_feature\\_column= tf.feature\\_column.categorical\\_column\\_with\\_vocabulary\\_file(key=“ a feature returned by input\\_fn()”, vocabulary\\_list=“…..txt”, vocabulary\\_size=“”)\n* Hashed Column: when the number of categories is so big, tased bucket enables to specify the number of categories\n  * feature\\_id=hash(raw\\_feature) %hash\\_bucket\\_size\n  * hashed\\_feature\\_column = tf.feature\\_column.categorical\\_column\\_with\\_hash\\_bucket(key=“”, hash\\_buckets\\_size=)\n* Crossed Column: combine features into a single feature, enable the mode to learn separate weight for each combination of features\n* Indicator and Embedding Columns: rake categorical columns as input\n  * Indicator Column: treat each category as an element in a one-hit vector of many dimension, where the matching category has value 1 and the rest have 0\n  * Embedding Column: (when the number of categories grow large), represents data as a lower-dimensional, ordinary vector in which each cell can contain any number, not just 0 or 1\n    * embedding\\_column = tf.feature\\_column\\_embedding \\_column(caategorical\\_coumn=categorical\\_column, dimension=dimension\\_of\\_embedding\\_vector\n* Passing feature columns to estimator:\n  * LinearClassifier & LinearRegressor: all eyes of feature column\n  * DNNClassifier & DNNRegressor: dense columns (others must be wrapped in either an indicator\\_column or embedding\\_column)\n  * DNNLinearCombinedClassifier & DNNLinearCombinedRegressor: \n    * linear\\_feature\\_columns accepts any feature column types\n    * dnn\\_feature\\_columns accepts dense columns"
    }
  ]
}